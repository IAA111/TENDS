{% load static %}
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
     <link rel="stylesheet" href="{% static 'plugins/bootstrap-3.4.1/css/bootstrap.min.css' %}">
</head>
<body>

 <div id="main" style="width: 100%;height: 400px;">

</div>

<script src="{% static "plugins/jquery-3.7.1.min.js" %}"></script>
<script src="{% static "plugins/bootstrap-3.4.1/js/bootstrap.min.js" %}"></script>
<script src="{% static 'plugins/echarts.min.js' %}"></script>
<script type="text/javascript">


$(function (){
    initChart();
    updateChart();
})


var current_index = 0;
var myChart1 = echarts.init(document.getElementById('main'));
var maxSeriesLength = 20;
var maxRealLineSeriesLength = 20
var maxDashedLineSeriesLength = 5


var option = null;
var colors = ["#488f31", "#59cdaa", "#1b9be0", "#56428e", "#9c56b8", "#c23b75", "#ec2176", "#f03867", "#f66f4b", "#fca443", "#f3d72b", "#9edb40", "#30c16f", "#179f8c", "#147f9f", "#4986b5", "#7278a6", "#a066ab"];

function initChart(){
    option = {
        title: {
            text: ''
        },
        tooltip: {
            trigger: 'axis',
            axisPointer: {
                animation: false
            }
        },
        xAxis: {
            type: 'category',
            splitLine: {
                show: false
            }
        },
        yAxis: {
            type: 'value',
            boundaryGap: [0, '100%'],
            splitLine: {
                show: false
            },
            max: 'dataMax',
        },
        series: [],
        legend: {},
        animationDurationUpdate: 0,
    };
    myChart1.setOption(option);
}

function updateChart() {
    $.ajax({
        url: "/get_chart_data/",
        type: "GET",
        dataType: "json",
        success: function (res) {
            if(current_index < res.length) {  // 如果还有数据可获取
                var new_data = res[current_index];  // 获取一个数据点，而不是整个列表
                process_data(new_data);
                current_index++;  // 更新当前索引
            }
        }
    });
}

function process_data(newData) {
    var figureCount = newData.figures.length;

    while (option.series.length < figureCount * 2) {
        var figureNumber = Math.floor(option.series.length / 2);
        var isPredicted = option.series.length % 2 == 1;
        var color = colors[figureNumber % colors.length];
        var seriesName = 'Variable ' + (figureNumber + 1) + (isPredicted ? ' Predicted' : '');
        option.series.push({
            data: [],
            type: 'line',
            markPoint: {
                data: []
            },
            showSymbol: false,
             name: isPredicted ? '' : seriesName,
            lineStyle: isPredicted ? { type: 'dashed' ,width:5} : {},
            itemStyle: { color: color }
        });

    }

    newData.figures.forEach((value, i) => {
        if (option.series[i * 2].data.length >= maxRealLineSeriesLength) {
            option.series[i * 2].data.shift();
            if(option.series[i * 2].markPoint.data.length > 0){
                if (option.series[i * 2].markPoint.data[0].coord[0] <= newData.time - maxRealLineSeriesLength) {
                    option.series[i * 2].markPoint.data.shift();
                }
            }
        }

        var dataPoint = {
            name: newData.time,
            value: [newData.time, value],
        };

        option.series[i * 2].data.push(dataPoint);

        if(newData.predicted_figures[i] !== null) {
            if(option.series[i * 2 + 1].data.length >= maxDashedLineSeriesLength) {
                option.series[i * 2 + 1].data.shift();
                if(option.series[i * 2 + 1].markPoint.data.length > 0){
                    if (option.series[i * 2 + 1].markPoint.data[0].coord[0] <= newData.time - maxDashedLineSeriesLength) {
                        option.series[i * 2 + 1].markPoint.data.shift();
                    }
                }
            }

            var predictedDataPoint = {
                name: newData.time,
                value: [newData.time, newData.predicted_figures[i]],
            };

            option.series[i * 2 + 1].data.push(predictedDataPoint);
        }


        if (newData.highlighted_figures[i] !== null) {
            var markPoint = {
                coord: [newData.time, value],
                symbol: 'circle',
                symbolSize: 20,
                label: { show: false },
                animation: false,
                animationDurationUpdate: 0,
                itemStyle: { color: 'yellow' },
            };
            option.series[i * 2].markPoint.data.push(markPoint);
        }

        if (newData.highlighted_predicted_figures[i] !== null && newData.predicted_figures[i] !== null) {
            var markPoint = {
                coord: [newData.time, newData.predicted_figures[i]],
                symbol: 'circle',
                symbolSize: 20,
                label: { show: false },
                animation: false ,
                animationDurationUpdate: 0,
                itemStyle: { color: 'red' },
            };
            option.series[i * 2 + 1].markPoint.data.push(markPoint);
        }
    });

    myChart1.setOption({
        series: option.series,
        xAxis: {
            min: 'dataMin',
            max: 'dataMax'
        }
    });
}
// Use an interval to update the chart every second
setInterval(updateChart, 200);


</script>
</body>
</html>